# General Guidelines

## Development Guidelines

### Code Style Guidelines
- Commands: Place in Commands/ folder, use constructor injection, must implement command methods
- Options: Place in Options/ folder, must end with "Options" suffix
- Filters: Place in Filters/ folder, implement middleware pattern via UseFilter<T>
- Logging: Use ZLogger for structured logging (ZLog* methods)
  - IMPORTANT: Always use string interpolation with ZLogger by adding $ prefix to strings (`$"message {value}"`)
  - When logging exceptions, always use string interpolation: `logger.ZLogError(ex, $"Error message")`
  - Never use the string format style with positional parameters like `"Error {0}"` with ZLogger
- Configuration: Follow standard .NET patterns with environment-specific appsettings files
- Nullability: Default is disabled (Nullable=disable)
- Error handling: Use logging for errors, throw exceptions for unrecoverable errors
- Command parameters: Document with XML comments and use parameter validation attributes
- When checking for NULL use `is Null` rather than `== Null`
- External Tool Execution: 
  - Always use ProcessRunner for executing external commands
  - Track execution time with Stopwatch.GetTimestamp() and Stopwatch.GetElapsedTime()
  - Log both stdout and stderr outputs
  - Provide detailed feedback for tool installation when tools are missing
- Git Integration: Always check repository status before making changes in write mode

## Project Structure
- Commands/ - Application commands (each command = separate class)
  - ProcessRunner.cs - Handles external process execution with consistent logging
- Filters/ - Cross-cutting middleware pipeline components
- Options/ - Configuration option classes

### Code Modifications

- Always make **minimal** changes required to accomplish the task
- For each new command create a new profile in the Properties/launchSettings.json file

### Test Data Management Rules

- **CRITICAL:** Never manually create or edit files in the ExpectedLogs/ or ExpectedResults/ folders of integration tests
- Only create input files in TestData/Fixtures/ and TestData/Commands/ folders
- Let the test framework automatically generate .unverified files during the first test run
- Understand that the developer will manually verify and rename .unverified to .verified files

### Git Workflow


## Code Architecture

- The codebase implements a layered architecture with a clear inheritance hierarchy to maximize code reuse and minimize duplication
- **IMPORTANT:** Prefer loosely coupled code that is easy to test, read and maintain

## Instructions

### File Handling

- Always use Path.Combine() for path construction rather than string concatenation with hardcoded separators
- Use relative paths in configuration files whenever possible to improve cross-platform compatibility
- Prefer using System.IO methods over platform-specific file manipulation libraries when working across platforms

### Commands and Options Pattern

- ConsoleAppFramework is used for command-line parsing and execution
- All commands inherit from BaseCommand<TOptions> or specialized base classes
- Options classes use CLSCompliant attributes for command-line binding
- Commands run in read-only mode by default, requiring explicit write flag (-w) to modify files
- Commands follow the template method pattern with standardized execution flow
- Command results provide standardized metrics (processed, updated, error counts)

### Test Structure

The project uses a structured approach to integration tests with a clear naming convention and folder organization.

#### TestData Folder Organization

The test data is organized in a standard structure to promote consistency and maintainability:

```
TestData/
  ├── Commands/                   # Test input files organized by command
  │   └── CommandName1/           # Each command has its own folder
  │       └── FixtureName/        # Each fixture has its own folder
  │           └── TestName/       # Each test has its own folder with input files
  ├── ExpectedLogs/               # Expected log output files - DO NOT CREATE MANUALLY
  │   └── CommandName1/
  │       └── FixtureName/
  │           ├── WhenReadOnly/   # Scenarios for read-only mode
  │           │   └── TestName.verified.log - Generated by test framework
  │           └── WhenWriteEnabled/ # Scenarios for write mode
  │               └── TestName.verified.log - Generated by test framework
  ├── ExpectedResults/            # Expected file state after command execution - DO NOT CREATE MANUALLY
  │   └── CommandName1/
  │       └── FixtureName/
  │           ├── WhenReadOnly/
  │           │   └── TestName/
  │           │       └── file.verified.ext - Generated by test framework
  │           └── WhenWriteEnabled/
  │               └── TestName/
  │                   └── file.verified.ext - Generated by test framework
  └── Fixtures/                   # Shared baseline test environments - CREATE THESE
      ├── FixtureName1/           # Each fixture is a complete test environment
      └── FixtureName2/
```

**IMPORTANT:** Do not manually create files in the ExpectedLogs or ExpectedResults folders. These will be automatically generated by the test framework when running tests for the first time. The framework will create .unverified files that need to be verified and renamed to .verified files by the developer.

This structure allows for:
- Clear separation between input, expected output, and test fixtures
- Consistent naming conventions across all tests
- Easy addition of new tests by following the established pattern
- Automatic verification of both console output and file changes

#### Cross-Platform Testing Considerations

When writing tests that involve file operations, follow these guidelines:

1. **Path Construction**: Use `Path.Combine()` rather than hardcoded separators
   ```csharp
   // Good
   var path = Path.Combine(baseDir, "subfolder", "file.txt");
   
   // Bad
   var path = baseDir + "/subfolder/file.txt";
   var path = baseDir + "\\subfolder\\file.txt";
   ```

2. **Configuration Paths**: Use relative paths in test configuration files

3. **File Operations**: Use platform-agnostic file operations
   ```csharp
   // Use this
   foreach (string dirPath in Directory.GetDirectories(sourceDir, "*", SearchOption.AllDirectories))
   {
       string newDirPath = dirPath.Replace(sourceDir, destinationDir);
       Directory.CreateDirectory(newDirPath);
   }
   
   // Instead of platform-specific APIs like
   // FileSystem.CopyDirectory(sourceDir, destinationDir, overwrite: true);
   ```

### Test Naming Convention

Test methods follow this naming pattern:
```
[Command]_[Fixture]_[ScenarioName]_[TestName]
```

For example:
```csharp
public void AddFrontmatter_BasicDiagram_WhenWriteEnabled_ShouldAddToEmpty()
public void ValidateAlias_ComplexDiagram_WhenReadOnly_ShouldDetectIncorrectAliases()
```

The [ScenarioName] component typically starts with "When" to describe the condition being tested, such as:
- WhenWriteEnabled - Tests the command with the -w flag set to true
- WhenReadOnly - Tests the command without the -w flag (default behavior)

### Test Data Organization

Test data is organized in these main folders:
- `Fixtures/` - Shared baseline environments
- `Commands/` - Command-specific test inputs
- `ExpectedLogs/` - Expected command outputs (logs)
- `ExpectedResults/` - Expected file states after commands

Each of these follows a pattern to separate tests by command, fixture, scenario, and test name as appropriate.

### Test Execution Approach

The BaseCommandTest class provides core infrastructure for all command tests:
- Parsing test method names to extract command, fixture, scenario, and test name
- Building paths to test data, logs, and results based on the parsed components
- Creating test environments by copying fixtures to a temporary location
- Verifying command outputs against expected logs
- Verifying file changes against expected results

### Test Helper Methods

The BaseCommandTest class provides helper methods to simplify test code:

- `VerifyDescriptionFile(string componentId, string diagramId = "DIAG001", string patternToReplace = null)` 
  - Verifies a Description.md file against expected content
  - Uses component ID instead of requiring full path construction
  - Automatically handles path construction, file reading, and comparison
  - Simplifies test code compared to direct VerifyActualFileAgainstExpected usage
  - Makes tests more maintainable by centralizing path construction logic

#### Example Usage

Before:
```csharp
var expectedPath = Path.Combine(GetExpectedResultsPath(), "DIAG001", "COMP001", "Description.verified.md");
var actualPath = Path.Combine(GetTestDataPath(), "DIAG001", "COMP001", "Description.md");
VerifyActualFileAgainstExpected(actualPath, expectedPath);
```

After:
```csharp
VerifyDescriptionFile("COMP001");
```

This approach makes tests much cleaner, easier to read, and less prone to path construction errors.


